esphome:
    name: oled-mini
    friendly_name: OLED Mini

esp32:
    board: esp32-c3-devkitm-1
    framework:
        type: arduino

logger:

api:
    encryption:
        key: "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
    services:
        - service: push_message
          variables:
              message: string
          then:
              - lambda: |-
                    if (id(oled_force_off)) {
                        id(oled_force_off) = false;
                    }
                    id(oled_enabled) = true;

                    const std::string raw = std::string(message.c_str());
                    if (raw.empty()) return;

                    uint32_t until_ms = 0;
                    if (id(default_duration_s) > 0) {
                        until_ms = millis() + (uint32_t) id(default_duration_s) * 1000UL;
                    }

                    auto enqueue = [&](const std::string &t, const std::string &b, uint32_t u) {
                        const int next_tail = (id(msg_q_tail) + 1) % 8;
                        if (next_tail == id(msg_q_head)) {
                            id(msg_q_head) = (id(msg_q_head) + 1) % 8;
                        }
                        id(msg_q_title)[id(msg_q_tail)] = t;
                        id(msg_q_body)[id(msg_q_tail)] = b;
                        id(msg_q_until)[id(msg_q_tail)] = u;
                        id(msg_q_tail) = next_tail;
                    };

                    auto activate = [&](const std::string &t, const std::string &b, uint32_t u) {
                        id(cur_title) = t;
                        id(cur_body) = b;
                        id(cur_until_ms) = u;
                        id(cur_scroll_epoch_ms) = 0;
                    };

                    std::string title = "";
                    std::string body = raw;

                    const size_t nl = raw.find('\n');
                    if (nl != std::string::npos) {
                        title = raw.substr(0, nl);
                        body = raw.substr(nl + 1);
                    }

                    auto rtrim = [&](std::string &s) {
                        while (!s.empty() && (s.back() == '\r' || s.back() == '\n')) s.pop_back();
                    };
                    rtrim(title);
                    rtrim(body);

                    if (!id(cur_title).empty() || !id(cur_body).empty()) {
                        enqueue(id(cur_title), id(cur_body), id(cur_until_ms));
                    }
                    activate(title, body, until_ms);

                    id(oled).turn_on();

        - service: push_message_timed
          variables:
              message: string
              duration_s: int
          then:
              - lambda: |-
                    if (id(oled_force_off)) {
                        id(oled_force_off) = false;
                    }
                    id(oled_enabled) = true;

                    const std::string raw = std::string(message.c_str());
                    if (raw.empty()) return;

                    uint32_t until_ms = 0;
                    if (duration_s > 0) {
                        until_ms = millis() + (uint32_t) duration_s * 1000UL;
                    }

                    auto enqueue = [&](const std::string &t, const std::string &b, uint32_t u) {
                        const int next_tail = (id(msg_q_tail) + 1) % 8;
                        if (next_tail == id(msg_q_head)) {
                            id(msg_q_head) = (id(msg_q_head) + 1) % 8;
                        }
                        id(msg_q_title)[id(msg_q_tail)] = t;
                        id(msg_q_body)[id(msg_q_tail)] = b;
                        id(msg_q_until)[id(msg_q_tail)] = u;
                        id(msg_q_tail) = next_tail;
                    };

                    auto activate = [&](const std::string &t, const std::string &b, uint32_t u) {
                        id(cur_title) = t;
                        id(cur_body) = b;
                        id(cur_until_ms) = u;
                        id(cur_scroll_epoch_ms) = 0;
                    };

                    std::string title = "";
                    std::string body = raw;

                    const size_t nl = raw.find('\n');
                    if (nl != std::string::npos) {
                        title = raw.substr(0, nl);
                        body = raw.substr(nl + 1);
                    }

                    auto rtrim = [&](std::string &s) {
                        while (!s.empty() && (s.back() == '\r' || s.back() == '\n')) s.pop_back();
                    };
                    rtrim(title);
                    rtrim(body);

                    if (!id(cur_title).empty() || !id(cur_body).empty()) {
                        enqueue(id(cur_title), id(cur_body), id(cur_until_ms));
                    }
                    activate(title, body, until_ms);

                    id(oled).turn_on();

        - service: push_titled
          variables:
              title: string
              message: string
          then:
              - lambda: |-
                    if (id(oled_force_off)) {
                        id(oled_force_off) = false;
                    }
                    id(oled_enabled) = true;

                    const std::string t = std::string(title.c_str());
                    const std::string b = std::string(message.c_str());
                    if (t.empty() && b.empty()) return;

                    uint32_t until_ms = 0;
                    if (id(default_duration_s) > 0) {
                        until_ms = millis() + (uint32_t) id(default_duration_s) * 1000UL;
                    }

                    auto enqueue = [&](const std::string &tt, const std::string &bb, uint32_t u) {
                        const int next_tail = (id(msg_q_tail) + 1) % 8;
                        if (next_tail == id(msg_q_head)) {
                            id(msg_q_head) = (id(msg_q_head) + 1) % 8;
                        }
                        id(msg_q_title)[id(msg_q_tail)] = tt;
                        id(msg_q_body)[id(msg_q_tail)] = bb;
                        id(msg_q_until)[id(msg_q_tail)] = u;
                        id(msg_q_tail) = next_tail;
                    };

                    if (!id(cur_title).empty() || !id(cur_body).empty()) {
                        enqueue(id(cur_title), id(cur_body), id(cur_until_ms));
                    }

                    id(cur_title) = t;
                    id(cur_body) = b;
                    id(cur_until_ms) = until_ms;
                    id(cur_scroll_epoch_ms) = 0;

                    id(oled).turn_on();

        - service: set_default_duration
          variables:
              duration_s: int
          then:
              - lambda: |-
                    id(default_duration_s) = duration_s < 0 ? 0 : duration_s;

        - service: set_progress
          variables:
              percent: int
          then:
              - lambda: |-
                    if (id(oled_force_off)) {
                        id(oled_force_off) = false;
                    }
                    id(oled_enabled) = true;
                    id(oled).turn_on();

                    int p = percent;
                    if (p < 0) p = 0;
                    if (p > 100) p = 100;

                    id(progress_enabled) = true;
                    id(progress_percent) = p;

        - service: set_progress_labeled
          variables:
              label: string
              percent: int
          then:
              - lambda: |-
                    if (id(oled_force_off)) {
                        id(oled_force_off) = false;
                    }
                    id(oled_enabled) = true;
                    id(oled).turn_on();

                    int p = percent;
                    if (p < 0) p = 0;
                    if (p > 100) p = 100;

                    id(progress_enabled) = true;
                    id(progress_label) = std::string(label.c_str());
                    id(progress_percent) = p;

        - service: clear_progress
          then:
              - lambda: |-
                    id(progress_enabled) = false;
                    id(progress_label).clear();
                    id(progress_percent) = 0;

        - service: reset_display
          then:
              - lambda: |-
                    id(cur_title).clear();
                    id(cur_body).clear();
                    id(cur_until_ms) = 0;
                    id(cur_scroll_epoch_ms) = 0;

                    for (auto &t : id(msg_q_title)) t.clear();
                    for (auto &b : id(msg_q_body)) b.clear();
                    for (auto &u : id(msg_q_until)) u = 0;

                    id(msg_q_head) = 0;
                    id(msg_q_tail) = 0;

                    id(progress_enabled) = false;
                    id(progress_label).clear();
                    id(progress_percent) = 0;

        - service: display_on
          then:
              - lambda: |-
                    id(oled_enabled) = true;
                    id(oled_force_off) = false;
                    id(oled).turn_on();

        - service: display_off
          then:
              - lambda: |-
                    id(oled_force_off) = true;
                    id(oled_enabled) = false;
                    id(oled).turn_off();

ota:
    - platform: esphome
      password: "yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"

wifi:
    ssid: !secret wifi_ssid
    password: !secret wifi_password
    ap:
        ssid: "Oled-Mini Fallback Hotspot"
        password: "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"

captive_portal:

i2c:
    sda: GPIO8
    scl: GPIO9
    scan: true
    frequency: 400kHz

font:
    - file: "gfonts://Roboto"
      id: font_small
      size: 11
      glyphs: ' !"#%&''()*+,-./:;=?@[]_°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzÄÖÜäöüß'

    - file: "gfonts://Roboto"
      id: font_title
      size: 14
      glyphs: ' !"#%&''()*+,-./:;=?@[]_°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzÄÖÜäöüß'

time:
    - platform: homeassistant
      id: ha_time

globals:
    - id: oled_enabled
      type: bool
      initial_value: "true"

    - id: oled_force_off
      type: bool
      initial_value: "false"

    - id: default_duration_s
      type: int
      initial_value: "0"

    - id: cur_title
      type: std::string
      initial_value: '""'
    - id: cur_body
      type: std::string
      initial_value: '""'
    - id: cur_until_ms
      type: uint32_t
      initial_value: "0"

    - id: cur_scroll_epoch_ms
      type: uint32_t
      initial_value: "0"

    - id: msg_q_title
      type: std::array<std::string, 8>
      initial_value: '{"", "", "", "", "", "", "", ""}'
    - id: msg_q_body
      type: std::array<std::string, 8>
      initial_value: '{"", "", "", "", "", "", "", ""}'
    - id: msg_q_until
      type: std::array<uint32_t, 8>
      initial_value: "{0, 0, 0, 0, 0, 0, 0, 0}"
    - id: msg_q_head
      type: int
      initial_value: "0"
    - id: msg_q_tail
      type: int
      initial_value: "0"

    - id: progress_enabled
      type: bool
      initial_value: "false"
    - id: progress_label
      type: std::string
      initial_value: '""'
    - id: progress_percent
      type: int
      initial_value: "0"

display:
    - platform: ssd1306_i2c
      model: "SSD1306 128x64"
      address: 0x3C
      id: oled
      update_interval: 200ms
      lambda: |-
          const uint32_t now = millis();

          auto dequeue_next = [&]() -> bool {
              if (id(msg_q_head) == id(msg_q_tail)) return false;

              id(cur_title) = id(msg_q_title)[id(msg_q_head)];
              id(cur_body) = id(msg_q_body)[id(msg_q_head)];
              id(cur_until_ms) = id(msg_q_until)[id(msg_q_head)];

              id(msg_q_title)[id(msg_q_head)].clear();
              id(msg_q_body)[id(msg_q_head)].clear();
              id(msg_q_until)[id(msg_q_head)] = 0;

              id(msg_q_head) = (id(msg_q_head) + 1) % 8;
              id(cur_scroll_epoch_ms) = 0;
              return true;
          };

          if ((!id(cur_title).empty() || !id(cur_body).empty()) && id(cur_until_ms) != 0 && ((int32_t)(id(cur_until_ms) - now) <= 0)) {
              id(cur_title).clear();
              id(cur_body).clear();
              id(cur_until_ms) = 0;
              id(cur_scroll_epoch_ms) = 0;
          }

          if (id(cur_title).empty() && id(cur_body).empty()) {
              dequeue_next();
          }

          if (id(oled_force_off) || !id(oled_enabled)) {
              it.clear();
              return;
          }

          it.clear();
          it.strftime(96, 0, id(font_small), "%H:%M", id(ha_time).now());

          const int progress_reserved = id(progress_enabled) ? 18 : 0;
          const int content_bottom = 64 - progress_reserved;

          std::string title = id(cur_title);
          std::string body = id(cur_body);
          std::string icon = "";

          auto ltrim_spaces = [&](std::string &s) {
              while (!s.empty() && (s.front() == ' ' || s.front() == '\t')) s.erase(s.begin());
          };

          auto has_prefix = [&](const std::string &p) -> bool {
              return title.size() >= p.size() && title.rfind(p, 0) == 0;
          };

          if (!title.empty()) {
              if (has_prefix("[!]")) {
                  icon = "warn";
                  title = title.substr(3);
              } else if (has_prefix("[i]")) {
                  icon = "info";
                  title = title.substr(3);
              } else if (has_prefix("[ok]")) {
                  icon = "ok";
                  title = title.substr(4);
              } else if (has_prefix("[x]")) {
                  icon = "x";
                  title = title.substr(3);
              }
              ltrim_spaces(title);
          }

          auto draw_icon = [&](int x, int y) {
              if (icon.empty()) return;

              if (icon == "warn") {
                  it.triangle(x + 8, y + 0, x + 0, y + 14, x + 16, y + 14);
                  it.line(x + 8, y + 4, x + 8, y + 10);
                  it.filled_circle(x + 8, y + 12, 1);
              } else if (icon == "info") {
                  it.circle(x + 8, y + 8, 7);
                  it.filled_circle(x + 8, y + 5, 1);
                  it.line(x + 8, y + 7, x + 8, y + 13);
              } else if (icon == "ok") {
                  it.circle(x + 8, y + 8, 7);
                  it.line(x + 4, y + 9, x + 7, y + 12);
                  it.line(x + 7, y + 12, x + 13, y + 5);
              } else if (icon == "x") {
                  it.circle(x + 8, y + 8, 7);
                  it.line(x + 4, y + 4, x + 12, y + 12);
                  it.line(x + 12, y + 4, x + 4, y + 12);
              }
          };

          const int max_chars = 21;
          const uint32_t tick_ms = 250;
          const uint32_t pause_ms = 1200;

          auto render_scrolling_line = [&](int x, int y, const std::string &s) {
              if (s.empty()) return;

              if ((int)s.size() <= max_chars) {
                  it.printf(x, y, id(font_small), "%s", s.c_str());
                  return;
              }

              if (id(cur_scroll_epoch_ms) == 0) id(cur_scroll_epoch_ms) = now;

              const uint32_t elapsed = now - id(cur_scroll_epoch_ms);
              const uint32_t steps = (uint32_t)(s.size() - max_chars + 1);
              const uint32_t run_ms = steps * tick_ms;
              const uint32_t cycle_ms = pause_ms + run_ms + pause_ms;
              const uint32_t in_cycle = elapsed % cycle_ms;

              uint32_t start = 0;
              if (in_cycle < pause_ms) {
                  start = 0;
              } else if (in_cycle < pause_ms + run_ms) {
                  start = (in_cycle - pause_ms) / tick_ms;
                  if (start >= steps) start = steps - 1;
              } else {
                  start = steps - 1;
              }

              it.printf(x, y, id(font_small), "%s", s.substr(start, max_chars).c_str());
          };

          int content_y = 0;

          if (!title.empty()) {
              int x_title = 0;
              if (!icon.empty()) {
                  draw_icon(0, 0);
                  x_title = 18;
              }
              it.printf(x_title, 0, id(font_title), "%s", title.c_str());
              content_y = 16;
          } else {
              content_y = 2;
          }

          std::array<std::string, 16> lines;
          lines.fill("");

          int li = 0;
          std::string cur;
          for (size_t i = 0; i < body.size(); i++) {
              const char c = body[i];
              if (c == '\r') continue;
              if (c == '\n') {
                  if (li < (int)lines.size()) lines[li++] = cur;
                  cur.clear();
                  if (li >= (int)lines.size()) break;
                  continue;
              }
              cur.push_back(c);
          }
          if (li < (int)lines.size() && !cur.empty()) {
              lines[li++] = cur;
          }

          const int line_h = 10;
          const int available_h = content_bottom - content_y;
          const int max_visible = available_h / line_h;

          int non_empty = 0;
          for (int i = 0; i < (int)lines.size(); i++) {
              if (!lines[i].empty()) non_empty++;
          }

          if (title.empty() && non_empty == 0 && (id(msg_q_head) == id(msg_q_tail))) {
              if (!id(progress_enabled)) {
                  it.printf(0, 22, id(font_title), "Bereit");
                  it.printf(0, 40, id(font_small), "warte auf Nachricht");
              }
          } else {
              const bool need_pages = non_empty > max_visible && max_visible > 0;
              int page = 0;

              if (need_pages) {
                  const uint32_t page_ms = 3000;
                  const int total_pages = (non_empty + max_visible - 1) / max_visible;
                  page = (now / page_ms) % total_pages;
              }

              int skip = page * max_visible;
              int shown = 0;
              int y = content_y;

              for (int i = 0; i < (int)lines.size(); i++) {
                  if (lines[i].empty()) continue;

                  if (skip > 0) {
                      skip--;
                      continue;
                  }
                  if (shown >= max_visible) break;

                  render_scrolling_line(0, y, lines[i]);
                  y += line_h;
                  shown++;
              }
          }

          if (id(progress_enabled)) {
              const int label_y = 46;
              const int bar_x = 0;
              const int bar_y = 56;
              const int bar_w = 128;
              const int bar_h = 8;

              // Bereich explizit leeren, damit nichts "durchscheint"
              it.filled_rectangle(0, 46, 128, 18);

              if (!id(progress_label).empty()) {
                  it.printf(0, label_y, id(font_small), "%s", id(progress_label).c_str());
              } else {
                  it.printf(0, label_y, id(font_small), "Fortschritt: %d%%", id(progress_percent));
              }

              it.rectangle(bar_x, bar_y, bar_w, bar_h);

              int p = id(progress_percent);
              if (p < 0) p = 0;
              if (p > 100) p = 100;

              const int fill_w = (bar_w - 2) * p / 100;
              if (fill_w > 0) {
                  it.filled_rectangle(bar_x + 1, bar_y + 1, fill_w, bar_h - 2);
              }
          }
